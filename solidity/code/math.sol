    pragma solidity ^0.8.0;
    
    contract Position{
        
       uint [91] distanceMap  =[
    110604, 110587, 110537, 110452, 110335, 110183, 109998,
    109779, 109528, 109242, 108924, 108572, 108187, 107769,
    107318, 106835, 106319, 105771, 105190, 104578, 103934,
    103258, 102550, 101811, 101042, 100241,  99410,  98549,
     97657,  96736,  95786,  94806,  93797,  92760,  91694,
     90601,  89480,  88332,  87157,  85955,  84727,  83473,
     82194,  80890,  79561,  78208,  76831,  75431,  74008,
     72562,  71094,  69605,  68094,  66563,  65011,  63439,
     61848,  60239,  58611,  56965,  55301,  53621,  51925,
     50213,  48485,  46743,  44986,  43216,  41433,  39636,
     37828,  36009,  34178,  32337,  30486,  28626,  26757,
     24880,  22996,  21104,  19206,  17302,  15393,  13479,
     11561,   9640,   7715,   5788,   3860,   1930,      0
  ];
  
  function floor(uint a) public returns(uint)
  {
      return a;
  }
  
    function sqrtu (uint256 x) public pure returns (uint128) {
    unchecked {
      if (x == 0) return 0;
      else {
        uint256 xx = x;
        uint256 r = 1;
        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }
        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }
        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }
        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }
        if (xx >= 0x100) { xx >>= 8; r <<= 4; }
        if (xx >= 0x10) { xx >>= 4; r <<= 2; }
        if (xx >= 0x8) { r <<= 1; }
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1; // Seven iterations should be enough
        uint256 r1 = x / r;
        return uint128 (r < r1 ? r : r1);
                 }
             }
         }
    function 
  
}

