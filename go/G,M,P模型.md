<img src="/Users/jundongchen/Library/Application Support/typora-user-images/image-20201205141333385.png" alt="image-20201205141333385" style="zoom:50%;" />

G,代表Goroutine ,存储一个协程的运行堆栈。

P,代表处理器，提供运行环境，如内存的分配状态等。接着一个local队列，这个队列绑定在p上

M，代表内核线程，从p中获取协程，转到协程的栈中执行，执行完后就返回M

sched，调度器，协调p,g,M之间的分配和调度。

当M绑定的P的的局部队列已经满了之后就会把goroutine放到全局队列

G是复用的，M也是复用的，G可跨M调度

**在同一个goroutine中创建的多个任务中最后创建那个任务最可能先被执行**。

[协程运行的解释](https://juejin.cn/post/6844903918120484872)



**理解GMP模型前先理解线程调度**。

线程调度发生的的前提是，操作系统对cpu有控制权。

1、cpu从用户态切换到内核态执行系统调用的时候（系统调用），会发生线程调度，因为必须要执行到内核代码才算调度

2、当系统发生硬件中断时会发生线程调度，系统会进行抢占调度，执行异常处理程序

线程调度可以理解为：**内核调度器对不同线程使用的寄存器和栈的切换**

操作系统的内核线程有自己的 栈和寄存器，因此**执行系统调用时必然会发生线程调度**



线程至少要包含3部分内容

1、通用寄存器的值

2、下一条指令的地址

3、栈顶栈底地址

当发生线程切换的时候，会将这些内容放到cpu中执行。



用户代码和runtime与内核的关系

![image-20201225114354810](/Users/jundongchen/Library/Application Support/typora-user-images/image-20201225114354810.png)



go调度器，不断从本地寻找可运行的g进行调度。
g结构体中，有gobuf结构，保存调度前现场信息，指令地址，寄存器值，栈地址等。
gobuf会存在g中，抢占执行完后，会从
gobuf中恢复现场信息。

schedt是全局调度器， 存放p,m的空闲队列，存放工作线程的最大数量，存放全局g队列
gfree 保存用完的g结构体，避免每次创建g都要分配内存。

M结构体里，存着g0,用于保存工作线程(当前M对应的内核线程)使用到的栈信息，执行用户g协程时，会用到这个栈，将g的栈信息放到g0来，作为当前执行的g的环境。
TLS指的是线程的本地存储。放在M结构体中，起着将M与实际线程绑定的作用

p存在m中，绑定时即有效

p使用数组维护本地运行队列g，保存内存分配用到的缓存。
使用p的好处是，它维护了局部的运行队列以及局部内存，为m运行g提供条件，使g从全局中解放出来，类似分流并发的作用，如果只有全局队列，当g的数量变多时，仅仅使用mutex控制同步不可能

p会监视每个协程的函数调用时间，如果超过10ms，则该协程会被标上可抢占。



工作流程:新创建的g会放到p的本地队列，如果满了就放到全局队列。M会被p唤醒(自己找事情干)，从p中找可运行的g，找不到则到全局队列和网络轮询器去找，再找不到则到别的队列里偷一半。

go的调度时机:
1.当新的g被创建，调度器会考虑调度，并将它塞进本地队列的第一个，如果满了就放到全局队列
2.当**g执行到系统调用时，g和对应的m会被阻塞**，p会放弃m去寻找其他的m进行调度。

3**.当g遇到chan或者mutex或者automic等同步内存访问时，g会被停放，挂到网络轮询器上，m会执行其他的g，一旦轮询发现可以运行了，则会回到原来的m上并且优先运行**（go1.5版本的改进）

p的加入实现了将内核级别的切换转成用户级别的切换。

https://mp.weixin.qq.com/s/JOjUWp15JbEu54VJHY8i_A

**GMP模型中的g0，特殊的协程**

g0是OS线程创建时创建的第一个协程，与普通的协程相比，有更大的堆栈（64kb），肩负不一样的责任。

GO通过GOMAXPROCS限制了OS线程的最大运行数量，对于每个线程，GO需要分配一个协程来管理这个线程的运行。即g0。**实际上g0就是一个存在于M里的g，与普通g不同它有调度栈**

**g0的职责**

1、管理当前P的 goroutine调度

当有新的g创建，g0会将其分配到本地队列，如果有g1切换到g2，需要经过g0调度

2、帮助g进行栈增长。



以前MPG模型，没有P，只有一个全局队列，所有的M都挂在全局队列上取G来运行。当进行线程调度时，是将M里的G切换到另一个M里的G，这是内核线程切换。比较耗费。并且多个M调用一个队列中的G，需要全局锁来控制。

1、需要全局锁来控制全局队列里g的运行（保证不被多个M同时占有）

2、G阻塞时M一起阻塞，发生线程调度时（系统调用），是M与M之间的切换，也就是线程级别的切换



现在存在p后，不一样在于，P对应cpu的核数，能够单独掌管执行线程所需的资源比如Mchache，当G阻塞时，可以将M解放出来去执行别的g。而不是让M与g一起阻塞，从而浪费了资源。

1、P管理着运行线程所需的内存，以及本地队列，当M阻塞时（系统调用时M和G会阻塞等待系统调用返回的结果），P会利用空隙去找别的M

2、一个本地队列，只有一个M来运行，无需锁。

3、当因非系统调用阻塞发生调度时，g可以被**网络轮询器**挂起，M可继续执行别的g.

4、g之间的切换不涉及到内核线程的切换，并且g本身就比线程轻量，所以g切换开销小。

5、由于有网络轮询器，可以使g挂起，M去执行其他的g。就算M和G一起被阻塞，P也可以去执行其他的M



**GMP的调度策略：**

1、对线程的复用。

线程M和p的关系是一对一，但是M的数量往往多于p，M需要绑定p才能执行g。

g在阻塞时，M会寻找别的g。

2、并发操作。设置多个p

3、抢占，sysmon会记录协程的运行时间，最长超过10ms即可以被抢占。